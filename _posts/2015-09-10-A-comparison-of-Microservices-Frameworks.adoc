= A comparison of Microservices Frameworks
:hp-tags: Tech, Microservices, REST

Microservice is probably one of the most used term nowadays when speaking about software architecture. Although the underlying concepts aren't new, it is one of the biggest buzzword of the two last years.

To summarize, big monolithic architectures tend to become not very maintainable and extendable when they grow over a certain size. Moreover, they don't scale well (you scale by multiplying big applications), and you can't replace old parts easily.

One of the biggest advantages of microservices is to address these concerns: instead of building an entire application as one block, one can build it as a set of services which will communicate over some kind of messaging system (most of the time, REST over HTTP). Given that, you will be able to replace one piece if you need to, you can scale only one piece because you need to, and so on.

But there is a counterpart: as you're building a distributed system, you will have the disadvantages of a distributed system. Building a distributed system as microservices architecture is not that easy, but fortunately there are many frameworks to help you. This article will present some of them.


== Requirements

I don't want to make another comparison based on some "Hello World" application. Most of the frameworks provide a simple way to start a server and respond to a simple request with only one line.

But this is not the real life. In the real life, you should not use plain HTTP. You would use REST / HTTPS and have an HTTPS client. You would add a Location header after a successful creation, and add links to your JSON or XML representations. You should have metrics included, to monitor your application. You have some kind of security to protect the access to your API.

Here is a list of what I am going to evaluate.

* I'm about to build a tiny RESTful API. UI is not considered in this article (note that every candidate framework has a mean to serve static resources easily)
* Only use HTTPS to access the API
* The API will have two sets of resources (aka two microservices). For simplicity's sake, they will be deployed in the same server, but will communicate over HTTPS.
* The resource will have a JSON representation
* Each representation will have at least a self link to the resource
* After a resource creation, client receive a Location header (the resource's link)
* The API will be accessible only by people providing a Facebook OAuth token
* Each API must have a monitoring / metrics facility
* Each service may be packaged as a standalone jar, to be run using `java -jar`.
* On the performance side, I will measure:
** request time of POST and GET
** the startup time of each server (not that important, but interesting)
** the memory footprint of the application
* Finally, I will give the final size of the package.

== The candidates

Here is the list of candidates:

* http://www.dropwizard.io/[Dropwizard]
* http://vertx.io/[Vertx]
* http://projects.spring.io/spring-boot/[Spring Boot]
* http://restlet.com/projects/restlet-framework/[Restlet]
* http://sparkjava.com/[Spark] + http://unirest.io/java.html[Unirest] (REST client, Spark doesn't provide a REST client itself)

Note that Restlet and Spark doesn't claim to be MicroServices frameworks, but Restlet is known to be a very good REST framework, and Spark is so lightweight that I couldn't resist to try it against bigger frameworks like Spring Boot.

== Prerequisites

Each sample run with a simple `java -jar` command. You will need to set some properties to enable ssl: `-Djavax.net.ssl.trustStore=... -Djavax.net.ssl.trustStorePassword=... -Djavax.net.ssl.keyStorePassword=... -Djavax.net.ssl.keyStorePath=...`.

In order to be able to run the samples, you need to create a keystore (see http://www.javacodegeeks.com/2014/07/java-keystore-tutorial.html[this tutorial] for example), and install a self-signed certificate. You will need the Facebook certificate too (see http://serverfault.com/questions/139728/how-to-download-the-ssl-certificate-from-a-website[here] how to get it), and a user token (see https://developers.facebook.com/).

Don't forget to modify the configuration files and system properties accordingly. All these steps are explained in the README file.

== Dropwizard

As stated by its website, "`Dropwizard is a Java framework for developing ops-friendly, high-performance, RESTful web services.`". It is a bundle of some successful libraries such as Jetty, Jersey and Jackson. The documentation is very good, I've found everything I needed inside; a good point, as I hate being forced to search for minutes (hours?) for something said simple.

=== Main

The main mehod is quite simple: you just build an `Application` instance and run it:
[source,java]
----
public static void main(String[] args) throws Exception {
    new DropwizardApplication().run(args);
}
----

The `DropwizardApplication` class contains all the plumbing: resource and health checks registration, Guice bootstrapping and Jackson's `ObjectMapper` configuration. It is given an instance of a configuration class (`DropwizardServerConfiguration`) which is a POJO holding the configuration properties read from the YAML file passed as parameter to our application. 

The app is run with parameters: `java -jar app.jar server config.yml`. The `server` parameter is here to tell Dropwizard to start the server, but you can also manipulate the database (I didn't try this).

=== Resources

Under the hood, Dropwizard uses Jersey, so the resources are just POJOs annotated with (a lot of) JAX-RS annotations:

[source,java]
----
@Path("/cars/{id}")
@Produces(MediaType.APPLICATION_JSON)
public class CarResource {

    @Context
    UriInfo uriInfo;

    @Inject
    private CarRepository carRepository;

    @GET
    public Response byId(@Auth User user, @PathParam("id") int carId) {
        Optional<Car> car = carRepository.byId(carId);
        return car.map(c -> {
            CarRepresentation carRepresentation = new CarRepresentation(c);
            carRepresentation.addLink(Link.self(uriInfo.getAbsolutePathBuilder().build(c.getId()).toString()));
            return Response.ok(carRepresentation).build();
        }).orElse(Response.status(Response.Status.NOT_FOUND).build());
    }
}
----

All the underlying HTTP handling is done by the framework, you have no mandatory access to request and response objects. In this case, the return is a `Response` but I could simply have returned the object; however, in that case the return code would not be the right one (201), so to have full control over it, I prefer that solution. Moreover, the 404 (Status.NOT_FOUND) is set on the response; I could throw an exception instead, and write a mapper to make an adequate response, but it's overkill (and I hate so-called "Business Exceptions").

Note that injection is performed by Guice. It seems that there is a CDI container provided with Jersey (hk2), but I didn't managed to make it work. Linking is handmade, and quite easy with the `UriInfo` object. 

Dropwizard uses Jackson to serialize / deserialize the object returned to JSON, so you have nothing special to do... but you have to configure the `ObjectMapper` to disable errors on unknown properties (see http://martinfowler.com/bliki/TolerantReader.html[Tolerant Reader]).

=== HTTPS

HTTPS is configured in the YAML configuration file. The documentation explains exactly how to set it up, and there is no surprise here.

=== REST client

The REST client is built by Guice, as a singleton; it is not managed as documented, I didn't managed to make it work this way. Otherwise, nothing special about the client, the API is fluent and simple:

[source,java]
----
@Override
public List<Car> getAllCars(String auth) {
    WebTarget target = client.target("https://localhost:8443/app/cars");
    Invocation invocation = target.request(MediaType.APPLICATION_JSON)
            .header("Authorization", "Bearer " + auth)
            .build(HttpMethod.GET);
    Car[] cars = invocation.invoke(Car[].class);
    return asList(cars);
}
----

=== Security

The authentication requires two things: first, implement the `Authenticator` interface. Note that he single method `authenticate` returns an `Optional<User>`, but not a Java 8's `Optional`, the Guava's one! What a pity... Nevermind. Second, you need to register the authenticator against Jersey:

[source,java]
----
environment.jersey().register(AuthFactory.binder(
                new OAuthFactory<>(guiceBundle.getInjector().getInstance(FacebookTokenAuthenticator.class),
                        getName() + "-Realm",
                        User.class)));
----

So far so good, it works as expected.

=== Monitoring

Dropwizard has a built-in monitoring system. You can register healthchecks to ensure that the app is up, and each resource can be metered simply using annotations. You can also add custom metrics, using the metrics registry obtained from the `Environment`.

=== Conclusion

While a bit verbose due to all the plumbing involved in the setup, Dropwizard is a nice framework. It provides all the functions needed to build a MicroServices-based application. However, to build tiny services, the amount of plumbing required can be too high compared to the business code; I would not recommend to use it in that case. Otherwise, you cannot go wrong!


== Vertx

"`Vertx is a tool-kit for building reactive applications on the JVM.`". You can develop with it in Java of course, but also many languages running on the JVM (Javascript, Scala, Ruby, Python, Clojure).

It also provides an actors-like system, the "verticles", which allow deployment of independent, concurrent, and potentially written in different language, services communicating over an event bus. As stated by the documentation, you are not forced to use this model (I didn't in this case, however I will give it a try!).

=== Main

The framework abstracts low level handling of HTTP, but you need to create the server by hand:

[source,java]
----
Vertx vertx = Vertx.create();
HttpServer server = vertx.createHttpServer(serverOptions);
----

Maybe you noticed the serverOptions parameter (sure you did!). This is the definition:

[source, java]
----
HttpServerOptions serverOptions = new HttpServerOptions()
                .setSsl(true)
                .setKeyStoreOptions(new JksOptions()
                        .setPath(System.getProperty("javax.net.ssl.keyStorePath"))
                        .setPassword(System.getProperty("javax.net.ssl.keyStorePassword")))
                .setPort(8090);
----

This object allows to set the port and SSL properties.

=== Resources

=== HTTPS

=== REST Client

=== Security

=== Monitoring

=== Conclusion

TODO...
Its style is really puzzling at first sight for people like me that are not used to asynchronous programming. But once you get the thing, it's probably one of the best tools I ever used.

== Spring Boot

=== Main

=== Resources

=== HTTPS

=== REST Client

=== Security

=== Monitoring

=== Conclusion

== Restlet

=== Main

=== Resources

=== HTTPS

=== REST Client

=== Security

=== Monitoring

=== Conclusion

== SparkJava

=== Main

=== Resources

=== HTTPS

=== REST Client

=== Security

=== Monitoring

=== Conclusion


...

////
Toute remarque et aide à l'amélioration est bienvenue :)
////

== A conclusion
It's been a long journey. The study is not as complete as I first wanted, but I guess it's a good start.


NOTE: TODO blah blah...

All the code is available on github (give link). You are free and encouraged to fork, play with the code and give feedback.
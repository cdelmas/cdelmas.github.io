= A comparison of Microservices Frameworks
:hp-tags: Tech, Microservices, REST

Microservice is probably one of the most used term nowadays when speaking about software architecture. Although the underlying concepts aren't new, it is one of the biggest buzzword of the two last years.

To summarize, big monolithic architectures tend to become not very maintainable and extendable when they grow over a certain size. Moreover, they don't scale well (you scale by multiplying big applications), and you can't replace old parts easily.

One of the biggest advantages of microservices is to address these concerns: instead of building an entire application as one block, one can build it as a set of services which will communicate over some kind of messaging system (most of the time, REST over HTTP). Given that, you will be able to replace one piece if you need to, you can scale only one piece because you need to, and so on.

But there is a counterpart: as you're building a distributed system, you will have the disadvantages of a distributed system. Building a distributed system as microservices architecture is not that easy, but fortunately there are many frameworks to help you. This article will present some of them.


== Requirements

I don't want to make another comparison based on some "Hello World" application. Most of the frameworks provide a simple way to start a server and respond to a simple request with only one line.

But this is not the real life. In the real life, you should not use plain HTTP. You would use REST / HTTPS and have an HTTPS client. You would add a Location header after a successful creation, and add links to your JSON or XML representations. You should have metrics included, to monitor your application. You have some kind of security to protect the access to your API.

Here is a list of what I am going to evaluate.

* I'm about to build a tiny RESTful API. UI is not considered in this article (note that every candidate framework has a mean to serve static resources easily)
* Only use HTTPS to access the API
* The API will have two sets of resources (aka two microservices). For simplicity's sake, they will be deployed in the same server, but will communicate over HTTPS.
* The resource will have a JSON representation
* Each representation will have at least a self link to the resource
* After a resource creation, client receive a Location header (the resource's link)
* The API will be accessible only by people providing a Facebook OAuth token
* Each API must have a monitoring / metrics facility
* Each service may be packaged as a standalone jar, to be run using `java -jar`.
* On the performance side, I will measure:
** request time of POST and GET
** the startup time of each server (not that important, but interesting)
** the memory footprint of the application
* Finally, I will give the final size of the package.

== The candidates

Here is the list of candidates:

* http://www.dropwizard.io/[Dropwizard]
* http://vertx.io/[Vertx]
* http://projects.spring.io/spring-boot/[Spring Boot]
* http://restlet.com/projects/restlet-framework/[Restlet]
* http://sparkjava.com/[Spark] + http://unirest.io/java.html[Unirest] (REST client, Spark doesn't provide a REST client itself)

Note that Restlet and Spark doesn't claim to be MicroServices frameworks, but Restlet is known to be a very good REST framework, and Spark is so lightweight that I couldn't resist to try it against bigger frameworks like Spring Boot.

== Prerequisites

Each sample run with a simple `java -jar` command. You will need to set some properties to enable ssl: `-Djavax.net.ssl.trustStore=... -Djavax.net.ssl.trustStorePassword=... -Djavax.net.ssl.keyStorePassword=... -Djavax.net.ssl.keyStorePath=...`.

In order to be able to run the samples, you need to create a keystore, and install a self-signed certificate. You will need the Facebook certificate too, and a user token (see http://developers.facebook.com).

Don't forget to modify the configuration files and system properties accordingly. All these steps are explained in the README file.

== Dropwizard

As stated by its website, "`Dropwizard is a Java framework for developing ops-friendly, high-performance, RESTful web services.`". It is a bundle of some successful libraries such as Jetty, Jersey and Jackson. The documentation is very good, I've found everything I needed inside; a good point, as I hate being forced to search for minutes (hours?) for something said simple.

=== Main

The main mehod is quite simple: you just build an `Application` instance and run it:
[source,java]
----
public static void main(String[] args) throws Exception {
    new DropwizardApplication().run(args);
}
----

The `DropwizardApplication` class contains all the plumbing: resource and health checks registration, guice bootstrapping and Jackson's `ObjectMapper` configuration. It is given an instance of a configuration class (`DropwizardServerConfiguration`) which is a POJO holding the configuration properties read from the file passed as parameter to our application. 

Yes, there is a configuration file (a yaml file): the app is run like that; `java -jar app.jar server config.yml`. The `server` parameter is here to tell Dropwizard to start the server, but you can also manipulate the database (I didn't try this).

=== Resources

Under the hood, Dropwizard uses Jersey, so the resources are just POJOs annotated with JAX-RS annotations:

[source,java]
----
@Path("/cars/{id}")
@Produces(MediaType.APPLICATION_JSON)
public class CarResource {

    @Context
    UriInfo uriInfo;

    @Inject
    private CarRepository carRepository;

    @GET
    public Response byId(@Auth User user, @PathParam("id") int carId) {
        Optional<Car> car = carRepository.byId(carId);
        return car.map(c -> {
            CarRepresentation carRepresentation = new CarRepresentation(c);
            carRepresentation.addLink(Link.self(uriInfo.getAbsolutePathBuilder().build(c.getId()).toString()));
            return Response.ok(carRepresentation).build();
        }).orElse(Response.status(Response.Status.NOT_FOUND).build());
    }
}
----

Note that injection is performed by Guice. It seems that there is a container provided with Jersey (hk), but I didn't managed to make it work. Linking and response is straightforward, you just have to read the JAX-RS documentation. 

Dropwizard uses Jackson to serialize the object returned to JSON, so you have nothing to do.

=== HTTPS

HTTPS is configured in the YAML configuration file. The documentation explains exactly how to set it up. Sadly, the store password is not encrypted.

==== REST client

The REST client is built by Guice, as a singleton. Nothing special about that, that API is fluent and simple:

[source,java]
----
@Override
public List<Car> getAllCars(String auth) {
    WebTarget target = client.target("https://localhost:8443/app/cars");
    Invocation invocation = target.request(MediaType.APPLICATION_JSON)
            .header("Authorization", "Bearer " + auth)
            .build(HttpMethod.GET);
    Car[] cars = invocation.invoke(Car[].class);
    return asList(cars);
}
----

=== Security

The authentication requires two things: first, implement the `Authenticator` interface. Note that he single method `authenticate` returns an `Optional<User>`, but not a Java 8's `Optional`, the Guava's one! What a pity... Nevermind. Second, you need to register the authenticator against Jersey:

[source,java]
----
environment.jersey().register(AuthFactory.binder(
                new OAuthFactory<>(guiceBundle.getInjector().getInstance(FacebookTokenAuthenticator.class),
                        getName() + "-Realm",
                        User.class)));
----

So far so good.

=== Monitoring

Dropwizard has a built-in monitoring system. You can register healthchecks to ensure that the app is up, and each resource can be metered simply using annotations. You can also add custom metrics, using the metrics registry obtained from the `Environment`.

=== Conclusion

TO DO


== Vertx

"`Vertx is a tool-kit for building reactive applications on the JVM.`". Built with Java 8, it is an asynchronous general purpose tool, ...

== Spring Boot

== Restlet

== SparkJava

...

////
Toute remarque et aide à l'amélioration est bienvenue :)
////

== A conclusion
It's been a long journey. The study is not as complete as I first wanted, but I guess it's a good start.


NOTE: TODO blah blah...

All the code is available on github (give link). You are free and encouraged to fork, play with the code and give feedback.